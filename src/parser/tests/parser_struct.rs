use crate::parser::parser_struct::RpcParser;
use crate::parser::tests::allocator::MockAllocator;
use crate::parser::tests::socket::MockSocket;
use crate::parser::Arguments;
use crate::vfs::{file, fs_stat};

#[tokio::test]
async fn parse_two_correct() {
    let buf = vec![
        0x80, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x01, 0x86, 0xA3, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x80, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x86, 0xA3, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    ];
    let socket = MockSocket::new(buf.as_slice());
    let alloc = MockAllocator::new(0);
    let mut parser = RpcParser::new(socket, alloc, 0x35);
    for _ in 0..2 {
        let result = parser.parse_message().await.unwrap();
        let expected =
            fs_stat::Args { root: file::Handle([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]) };
        match *result {
            Arguments::FsStat(args) => {
                assert_eq!(args.root.0, expected.root.0);
            }
            _ => panic!("Wrong result type"),
        }
    }
}

#[tokio::test]
async fn parse_after_error() {
    let buf = vec![
        0x80, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x01, 0x86, 0xA3, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05,
        0x06, 0x07, 0x08, 0x80, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x86, 0xA3, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    ];
    let socket = MockSocket::new(buf.as_slice());
    let alloc = MockAllocator::new(0);
    let mut parser = RpcParser::new(socket, alloc, 0x50);
    let result = parser.parse_message().await;
    assert!(result.is_err());
    let result = parser.parse_message().await.unwrap();
    let expected =
        fs_stat::Args { root: file::Handle([0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08]) };
    match *result {
        Arguments::FsStat(args) => {
            assert_eq!(args.root.0, expected.root.0);
        }
        _ => panic!("Wrong result type"),
    }
}

#[tokio::test]
async fn parse_write() {
    #[rustfmt::skip]
    let buf = vec![
        0x80, 0x00, 0x00, 84, // head
        0x00, 0x00, 0x00, 0x01, // xid
        0x00, 0x00, 0x00, 0x00, // request
        0x00, 0x00, 0x00, 0x02, // rpc version
        0x00, 0x01, 0x86, 0xA3, // program
        0x00, 0x00, 0x00, 0x03, // prog vers
        0x00, 0x00, 0x00, 7, // proc
        0x00, 0x00, 0x00, 0x00, // auth
        0x00, 0x00, 0x00, 0x00, //auth
        0x00, 0x00, 0x00, 0x08, // nfs_fh3
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, // offset
        0x00, 0x00, 0x00, 0xFF, // count
        0x00, 0x00, 0x00, 0x00, // mode
        0x00, 0x00, 0x00, 0x12, // opaque
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x00, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04,
        0x80, 0x00, 0x00, 84, // head
        0x00, 0x00, 0x00, 0x01, // xid
        0x00, 0x00, 0x00, 0x00, // request
        0x00, 0x00, 0x00, 0x02, // rpc version
        0x00, 0x01, 0x86, 0xA3, // program
        0x00, 0x00, 0x00, 0x03, // prog vers
        0x00, 0x00, 0x00, 7, // proc
        0x00, 0x00, 0x00, 0x00, // auth
        0x00, 0x00, 0x00, 0x00, //auth
        0x00, 0x00, 0x00, 0x08, // nfs_fh3
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, // offset
        0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, // count
        0x00, 0x00, 0x00, 0x00, // mode
        0x00, 0x00, 0x00, 0x12, // opaque
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03,
        0x04, 0x01, 0x02, 0x03, 0x04,
    ];
    let socket = MockSocket::new(buf.as_slice());
    let alloc = MockAllocator::new(0x24);
    let mut parser = RpcParser::new(socket, alloc, 72);
    let result = parser.parse_message().await;
    assert!(result.is_ok());
    let result = parser.parse_message().await;
    assert!(result.is_ok());
}

#[tokio::test]
async fn parse_write_after_error() {
    let buf = vec![
        0x80, 0x00, 0x00, 84, // head
        0x00, 0x00, 0x00, 0x01, // xid
        0x00, 0x00, 0x00, 0x00, // request
        0x00, 0x00, 0x00, 0x05, // rpc version
        0x00, 0x01, 0x86, 0xA3, // program
        0x00, 0x00, 0x00, 0x03, // prog vers
        0x00, 0x00, 0x00, 7, // proc
        0x00, 0x00, 0x00, 0x00, // auth
        0x00, 0x00, 0x00, 0x00, //auth
        0x00, 0x00, 0x00, 0x08, // nfs_fh3
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, // offset
        0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, // count
        0x00, 0x00, 0x00, 0x00, // mode
        0x00, 0x00, 0x00, 0x12, // opaque
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03,
        0x04, 0x01, 0x02, 0x03, 0x04, 0x80, 0x00, 0x00, 84, // head
        0x00, 0x00, 0x00, 0x01, // xid
        0x00, 0x00, 0x00, 0x00, // request
        0x00, 0x00, 0x00, 0x02, // rpc version
        0x00, 0x01, 0x86, 0xA3, // program
        0x00, 0x00, 0x00, 0x03, // prog vers
        0x00, 0x00, 0x00, 7, // proc
        0x00, 0x00, 0x00, 0x00, // auth
        0x00, 0x00, 0x00, 0x00, //auth
        0x00, 0x00, 0x00, 0x08, // nfs_fh3
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, // offset
        0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, // count
        0x00, 0x00, 0x00, 0x00, // mode
        0x00, 0x00, 0x00, 0x12, // opaque
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02, 0x03,
        0x04, 0x01, 0x02, 0x03, 0x04,
    ];
    let socket = MockSocket::new(buf.as_slice());
    let alloc = MockAllocator::new(0x24);
    let mut parser = RpcParser::new(socket, alloc, 80);
    let result = parser.parse_message().await;
    assert!(result.is_err());
    let result = parser.parse_message().await;
    assert!(result.is_ok())
}
